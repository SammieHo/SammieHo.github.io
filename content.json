{"meta":{"title":"SammieHo's 学习慢炖","subtitle":null,"description":null,"author":"Sammieho","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-02-04T06:50:13.000Z","updated":"2017-02-04T06:51:10.025Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"layout: categories comments: false","raw":null,"content":null},{"title":"tags","date":"2017-02-04T06:50:38.000Z","updated":"2017-02-04T06:59:55.004Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"区别 client,page,offset,screen","slug":"ten","date":"2017-02-04T08:36:08.133Z","updated":"2017-02-04T09:10:13.697Z","comments":true,"path":"2017/02/04/ten/","link":"","permalink":"http://yoursite.com/2017/02/04/ten/","excerpt":"","text":"client 客户区坐标位置顾名思义，相对于 浏览器内容区域 视口 而言的clientX，clientY （不包含页面滚动的距离） 图示如下： screen 屏幕坐标位置相对于 整个显示器的屏幕而言的 screenX，screenY 图示如下： page，offset 页面坐标位置相对于整个网页，是算上滚动条的。 例如：网页的 width：980px; height: 3000px;那么 page 和 offset 的最大值就是 980 和 3000。 而 page 和 offset 的区别就是：IE8以下只支持offset。 图示如下： 参考资料-《Javascript高程》","raw":null,"content":null,"categories":[],"tags":[]},{"title":"事件监听—addEventListener","slug":"for","date":"2017-02-03T13:57:39.729Z","updated":"2017-02-03T13:58:36.002Z","comments":true,"path":"2017/02/03/for/","link":"","permalink":"http://yoursite.com/2017/02/03/for/","excerpt":"","text":"123elementObj.addEventListener(type,listener,useCapture);当监听对象触发指定的事件后，执行指定回调函数。 addEventListener相对于attachEvent优点： 一个事件可注册多个listener。 Listener的触发可以选择capture/bubbling。 对任何DOM元素都有效。 在内存问题上，使用预先声明的函数，比匿名函数的消耗更小。 移除指定的事件： 1removeEventListener(event,function,capture/bubble); event.target 在处理事件时会被用到，例如：12345function hide(event)&#123; var target = event.target || event.srcElement;//target兼容处理 event.target.style.display = &apos;none&apos;;&#125;obj.addEventListener(&apos;click&apos;,hide,false); 兼容：123456789101112131415function addEvent(obj,type,func)&#123; if(window.addEventListener)&#123; obj.addEventListener(type,func,false); &#125; else&#123; obj.addEventListener(&apos;on&apos;+type,func); &#125;&#125;or:function addEvent(obj,type,listener)&#123; obj.addEventListener? obj.addEventListener(type,func,false) : obj.addEventListener(&apos;on&apos;+type,func); return obj;&#125;","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"一道关于this和作用域的题目引发的思考","slug":"night","date":"2017-01-23T00:55:29.000Z","updated":"2017-02-03T14:03:08.895Z","comments":true,"path":"2017/01/23/night/","link":"","permalink":"http://yoursite.com/2017/01/23/night/","excerpt":"","text":"题目引发思考： 一天在freecodecamp的群里，讨论到this的问题，最后有一道这样的题目: 123456789101112131415161718var name = 'global';var A = &#123; name: 'obj', test: function()&#123; var name = 'gaga'; this.name = 'dose'; return function()&#123; console.log(name); return this.name; &#125;; &#125;&#125;;var B = A.test;console.log( A.test()() );console.log( B()() ); 我的初始答案是这样：gaga,dosegaga,global然而是错的…/(ㄒoㄒ)/~~ 我百思不得其解，为什么会这样呢？再想了一遍，思维很混乱，开始怀疑人生（抖腿）。 第二天起来，脑海一直浮现一句话： this 是在函数调用时才指定的！ this 是在函数调用时才指定的！ this 是在函数调用时才指定的！ 尝试：**为了理清思路，找到 this 的指向，我做了一些尝试： 12345** 最后得出：**A.test() 实际上调用了 foo() , this 的隐式绑定，指向 A 内部。所以 this.name = &quot;dose&quot; 是给 A.name 赋值。A.test()() 返回匿名函数，默认指向全局，此时 this.name 就是 window.name，输出 &quot;global&quot;。B() 实际等于全局的 foo()，此时 foo 内的 this 指向 window ，this.name 等于给 window.name 赋值，所以 B()()返回 &quot;dose&quot; 借此题重温this的机制： this是在运行时进行绑定的，他的绑定与函数声明的位置没有关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动对象（执行上下文），这个记录会包含函数在哪里被调用、函数的调用方式、传入的参数等信息，this就是这个记录的一个属性，会在函数执行过程中用到。 this的绑定规则： new 显示绑定 隐式绑定 默认绑定 this的好：可以在不同的上下文对象中重复使用函数，不用针对每个对象编写不同版本的函数。 举个栗子：12345678910111213141516171819202122function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greet = \"Hello,\" + identify.call( this ); console.log( greet );&#125;var me = &#123; name: \"Kyle\"&#125;;var you =&#123; name: \"Read\"&#125;;console.log( identify.call( me ) );console.log( identify.call( you ) );speak.call( me );speak.call( you ); Conclusion:函数可以自动引用合适的上下文。this 提供了一种更优雅的方式来隐式“传递”一个对象饮用，因此可以将API设计得更加简洁和易于复用。 最后谨记！ this是在函数调用时才指定的。 作用域是在写函数的时候已经确定了。","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"从柯里化函数，加深对递归的运用","slug":"seven","date":"2016-11-20T00:55:29.000Z","updated":"2017-02-03T14:01:22.886Z","comments":true,"path":"2016/11/20/seven/","link":"","permalink":"http://yoursite.com/2016/11/20/seven/","excerpt":"","text":"遇到过这么一道面试题 写出函数，实现 sum(2)(3) , sum(2,3) 当时我是这么写的：12345678910function sum(a)&#123; if(arguments.length == 2)&#123; return arguments[0] + arguments[1]; &#125; else&#123; return function (b)&#123; return a + b; &#125; &#125;&#125; 然后我就想不会这么简单吧吧吧吧吧吧吧！！应该是要写n个参数，或者回调的情况下的通用函数，最后，我就画画画，没写出来，还搞到答卷“花面猫”似的。 回来，我搜索了一下，涉及到curry，柯里化函数。我懵逼了，这素啥。原来是递归的原理，分次接收参数。嗯，我要的就是这效果。 下面是实现 123456789101112131415161718192021222324252627282930313233function curry(fn,curryArgs)&#123; return function()&#123; var args = Array.prototype.slice.call(arguments,0); // 首次调用时未提供最后一个参数 if(curryArgs !== undefined)&#123; args = args.concat(curryArgs); &#125; // 递归边界 if( !arguments.length )&#123; return fn.apply(null, args); &#125; else&#123; return curry(fn, args); &#125; &#125;&#125;function sumOf()&#123; var total = 0; for(var i=0; i&lt;arguments.length; i++)&#123; total += arguments[i]; &#125; return total;&#125;// 改造普通函数，返回柯里函数var sum = curry(sumOf);sum(2, 3)(1)(1)(1, 2, 3)(); 另一个方法：1234567891011121314151617181920212223242526272829303132function add() &#123; var total = 0; if (arguments.length) &#123; var arr1 = Array.prototype.slice.call(arguments); var mytotal = arrayAdder(arr1); return sum(mytotal); &#125; else &#123; return sum(); &#125; function sum() &#123; if (arguments.length) &#123; var arr = Array.prototype.slice.call(arguments); total = total + arrayAdder(arr); return sum; &#125; else &#123; return total; &#125; &#125; function arrayAdder(arr) &#123; var x = 0; for (var i = 0; i &lt; arr.length; i++) &#123; x = x + arr[i]; &#125;; return x; &#125;&#125;add(2, 3)(1)(1)(1, 2, 3)(); 最后一点！很重要！上面的解决方法是我参考了别人的文章/回答，总结下来的，若涉及到版权问题，请联系我删除，抱歉。目前，未能深入理解柯里化函数，我会在接下来继续思考。 参考文章： 从 sum(2)(3) == sum(2, 3) 到实现柯里化函数 JS中的柯里化(currying) JavaScript的柯里化函数 浅析 JavaScript 中的 函数 currying 柯里化 js 函数式编程之函数柯里化 另外一个方法式在stackflow 找到的回答。","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"Ajax 笔记","slug":"eight","date":"2016-11-11T00:55:29.000Z","updated":"2017-02-03T14:02:18.334Z","comments":true,"path":"2016/11/11/eight/","link":"","permalink":"http://yoursite.com/2016/11/11/eight/","excerpt":"","text":"工作原理创建 和 Code 创建XMLHttpRequest()对象； 创建HTTP请求，链接服务器，设置请求动作FET/POST，URL，异步/同步； 发送HTTP请求；（三次握手四次挥手） 设置响应状态变化时间onreadystatechange； 接受返回数据(responseText,readyState,status等)； 使用Javascript DOM 操作，实现局部刷新。 1234567891011121314151617181920function ajaxDemo()&#123; var objXml; if(window.XMLHttpRequest)&#123; objXml = new XMLHttpRequest(); &#125; else&#123; objXml = ActiveXObject(&quot;Microsoft.XMLHttp&quot;); &#125; objXml.open(&apos;get&apos;,&apos;demo.php&apos;,true); objXml.onreadystatechange = function()&#123; if(objXml.readyState == 2 &amp;&amp; objXml.status ==200)&#123; //do something... &#125; &#125; objXml.send();&#125; XHR对象属性 属性 描述 onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML: 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） statusText 伴随状态码的字符串信息 readyState的返回值 返回值 状态说明 0： 请求未初始化，open未调用； 1： Server链接已建立，open已调用； 2： 请求已接收，接收到头信息了； 3： 请求处理中，接收到响应主体了； 4： 请求已完成，且响应已就绪 =&gt; 响应完成了。 HTTP 状态码 状态码 说明 1xx： 信息类。表示接受到浏览器请求，进一步处理。 2xx： 成功。请求被正确接收，理解和处理。 3xx： 重定向。请求失败，客户采取进一步操作。 4xx： 客户端错误。 5xx： 服务器错误。服务器不能完成请求。 XHR对象方法 方法 描述 abort() 导致当前正在执行的请求被取消 getAllResponseHeaders() 返回包含所有响应头的名称和值的单个字符 getResponseHeader(name) 返回响应头中指定的名称和值 open(method,url,async,username,pwd) 设置HTTP方法（get或post）等 send(content) 发出带有指定主体内容的请求 setRequestHeader(name,value); 使用指定的名称和值设置请求头 Ajax 的 优缺点Ajax的优点传统Ajax的问题 可以无刷新改变页面内容，但无法改变页面URL。 改变URL 的hash不能很好的处理浏览器的前后，后退问题。 解决方法补充内容 GET 与 POST 异步 与 同步 三次握手四次挥手 参考内容 JavaScript学习总结（七）Ajax和Http状态字 Javascript 高级编程（第三版）","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"快速排序","slug":"five","date":"2016-11-11T00:55:29.000Z","updated":"2017-02-03T14:00:13.425Z","comments":true,"path":"2016/11/11/five/","link":"","permalink":"http://yoursite.com/2016/11/11/five/","excerpt":"","text":"思路 选一基准元素 point 分区操作(partition)：小于point放左边，大于point放右边，point最后的位置就是排序完成的位置。 重复步骤1.2 123456789101112131415161718192021222324252627282930313233343536373839404142function quickSort(array) &#123; //交换元素位置 function swap(arr, i, k) &#123; var temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; //分区操作，左小右大 function partition(arr, left, right) &#123; var sortIndex = left; var point = arr[right];//直接选最右的作为基准元素 for (var i = left; i &lt; right; i++) &#123; if (arr[i] &lt;= point) &#123; swap(arr, i, sortIndex); sortIndex++; &#125; &#125; swap(arr, sortIndex, right);//将基准元素放置在最后的正确位置 //console.log(arr); return sortIndex; &#125; function sort(arr, left, right) &#123; if (left &gt; right) &#123; return; &#125; var sortIndex = partition(arr, left, right); sort(arr,left,sortIndex-1); sort(arr, sortIndex + 1, right); &#125; sort(arr, 0, arr.length - 1); return array;&#125;quickSort(arr); 算法分析 快速排序的时间主要耗费在划分操作上，对长度为 k 的区间进行划分，共需 k-1 次关键字的比较。 最坏时间复杂度 最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)， 而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。 因此，快速排序必须做 n-1 次划分， 第i次划分开始时区间长度为 n-i+1，所需的比较次数为 n-i(1≤i≤n-1)，故总的比较次数达到最大值：Cmax = n(n-1)/2=O(n^2) 如果按上面给出的划分算法，每次取当前无序区的第 1 个记录为基准，那么当文件的记录已按递增序(或递减序)排列时， 每次划分所取的基准就是当前无序区中关键字最小(或最大)的记录，则快速排序所需的比较次数反而最多。 最好时间复杂度 在最好情况下，每次划分所取的基准都是当前无序区的”中值”记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。 总的关键字比较次数：O(nlgn) 注意： 用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为 O(lgn)， 而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数 C(n)=O(nlgn)。 因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为 O(n^2)，最好时间复杂度为 O(nlgn)。 平均时间复杂度 尽管快速排序的最坏时间为 O(n^2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。 它的平均时间复杂度为 O(nlgn)。 基准关键字的选取 在当前无序区中选取划分的基准关键字是决定算法性能的关键。 ”三者取中”的规则 “三者取中”规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准， 在划分开始前将该基准记录和该区伺的第1个记录进行交换，此后的划分过程与上面所给的 Partition 算法完全相同。 取位于 low 和 high 之间的随机数k(low≤k≤high)，用 R[k] 作为基准 选取基准最好的方法是用一个随机函数产生一个取位于 low 和 high 之间的随机数 k(low≤k≤high)，用 R[k] 作为基准， 这相当于强迫R[low..high]中的记录是随机分布的。用此方法所得到的快速排序一般称为随机的快速排序。 注意： 随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件， 一般不可能导致最坏情况的发生。算法的随机化不仅仅适用于快速排序，也适用于其它需要数据随机分布的算法。 空间复杂度 快速排序在系统内部需要一个栈来实现递归。若每次划分较为均匀，则其递归树的高度为 O(lgn)，故递归后需栈空间为 O(lgn)。 最坏情况下，递归树的高度为 O(n)，所需的栈空间为 O(n)。 参考文章 常见排序算法 - 快速排序 (Quick Sort) 理解快速排序算法","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"重新认识-盒子模型","slug":"newthr","date":"2016-11-08T00:55:29.000Z","updated":"2017-02-03T13:56:41.010Z","comments":true,"path":"2016/11/08/newthr/","link":"","permalink":"http://yoursite.com/2016/11/08/newthr/","excerpt":"","text":"最近被问到盒子模型，却发现自己顿了一下，会用，却说不出个所以然。这就是基础知识不扎实的漏洞！！！所以，以最短的语言自我归纳了n遍！ 首先，什么是盒子模型？简单来说，就是元素大小的呈现方式。有一句话这么说来着 “every element in web design is a rectangular box.” 每个盒子有四条边界：1外边距边界margin edge + 边框边界 border edge + 内边距边界padding edge + 内容边界content edge. 然后有两种模式：123标准盒模型：content width 和 content height 只包含内容的宽/高，不包含padding,border,margin。IE6- 怪异模式：content width 与 content height 包括 padding 和 border，不包括 margin。 好，预（hu）备（shuo）知（ba）识（dao）说完，进入运用。 Box-sizing用来改变CSS盒模型对元素宽高的计算方式。 语法：-moz-box-sizing | box-sizing : content-box | border-box | padding-box ; 值：12content-box : 默认值，标准盒模型。实际width = content width + padding + border + margin 123border-box : IE6- 怪异模式实际width = 内容的宽 (包含 padding-left + padding-right + border-left + border-right) + margin margin叠加123发生在普通文档流中块元素的垂直方向外边距，此时外边框高度取两者间较大的那个，行内框、 浮动框或绝对定位框之间的外边距不会叠加。","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"setTimeout()和setInterval()的单细胞感情","slug":"newtwo","date":"2016-11-06T00:55:29.000Z","updated":"2017-02-03T13:56:04.935Z","comments":true,"path":"2016/11/06/newtwo/","link":"","permalink":"http://yoursite.com/2016/11/06/newtwo/","excerpt":"","text":"一、简单的语法与浅层的区别语法：12var setT= window.setTimeout(func/code,delay);var setI = window.setInterval(func/code,delay); 嗯，基本上是一样的，相对还有clearTimeout(setT)和clearInterval(setI)。 当第二个参数delay缺省时，默认为0 当指定的值小于4毫秒，则增加到4ms（4ms是HTML5标准指定的，对于2010年及之前的浏览器则是10ms） 区别： setTimeout() 延时，只执行一次 setInterval() 每隔一段时间，循环执行。 一点点题外话，setTimeout递归调用自己~是可以模拟setInterval滴。12345var setT = setTimeout(ourself(),100);function ourself()&#123; /*code*/ setTimeout(ourself(),100);&#125; 二、定时器与线程的一些事情先讲讲Javascript的工作方式，不然后面就聊不下去咯~1. Javascript是单线程的 每个window执行一个js线程，在某个特定时刻只有特定的代码块能够执行，其他代码块被阻塞（后来的要排队是中华人民共和国的传统美德）。 因为Javascript的作用是 进行 交互 和 DOM操作，如果JS是多线程，那么试想一下一个线程在修改节点的内容，另一个线程要删除这个节点，那么，是修改还是删除？不知道。所以，为了避免复杂性，JS是单线程的。 2.通过回调函数进行异步 异步，就是当B等待A时，B去干别的事，当有通知时（即被告知A已完成时）B再去做该做的，而通知通过回调函数来完成。耗时几乎可忽略不计。例如鼠标点击，定时器触发，或者一个XMLHttpRequest完成等 3.不靠谱的setInterval 1234567891011121314151617181920function formatDate()&#123; //code...&#125;var timer, i = 0;function test()&#123; dateStart = new Date(); timer = setInterval(function()&#123; i++; console.log(&apos;Interval&apos; + i); &#125;,8000); for(var i = 0;i &lt; 5; i++)&#123; formatDate(dateStart); //5 second while( new Date() - dateStart &lt; 5*1000 )&#123; &#125; dateStart = new Date(); &#125;&#125;test(); 主函数test()执行时间约5*5=25。 按理来说：执行主函数期间setInterval被触发25/8=3次，s1,s2,s3那么test()执行完应立即回调3次，而回调时间基本不耗时。 实际上：在chrome下，执行以上代码，显示，setInterval在主函数执行完后，只回调了一次， 所以，定时器智能化，在任务队列里面只保留一个回调任务，时刻8秒，s1放进去，然后时刻16秒，主逻辑还在执行，s1还在等待，那么s2被丢弃，同理，s3被丢弃。 原因：如果在一个非常大的javascript代码块执行过程中把每次间隔定时器触发的回调函数都放入队列的话，导致的结果是当这个大javascript代码块执行完毕时，有很多的回调函数会被无延迟的依次执行（这和我们当初需要间隔执行的目的相违背），所以，浏览器采用的作法是当等待队列中没有间隔定时器的回调函数时才会放入一个间隔定时器的回调函数。 假设把定时器间隔设定为9秒，那么在主逻辑执行到25秒时间内，有如下调用： 时刻9秒生成回调s1，时刻18秒生成回调s2（丢弃），时刻27秒生成回调s3 结果，大概在第25秒主逻辑执行完毕，从任务队列里面取出s1执行，然后在第27秒，生成s3放到任务队列，然后JS运行时取出执行，s3-s1之间间隔，大概27-25=2s， 所以，定时器不靠谱不靠谱不靠谱！！不能保证每次执行会间隔起码9秒。 这种情况下，可以用setTimeout()嵌套调用，递归。 总结： setTimeout和setInterval的原理是不同的。 如果一个普通的定时器被阻塞了，他会等待直到有合适的时间。 如果间隔定时器回调函数执行时间过长，有可能无间隔的执行。 —————————— 2016.11.24 更新 ——————————————— 三、对于setTimeOut与setInterval的深入思考1234setTimeOut 是用来设定延迟时间1000ms和回调函数fn的定时器，那么，究竟是什么在计算时间呢？回调函数是在什么时候执行的呢？是在等待1000ms的时候？还是一开始就执行了呢？ 1 是什么在计算时间浏览器内核相应模块(例如Webkit 的 Timer 模块)。 2 回调函数的执行 这里跟Event Loop 有关系了。我将js理解为2个线程，1个是主线程，同步；另一个是 任务队列，异步回调的函数就在此处排队。待主线程空闲，就从任务队列中读取事件，这个过程就是事件循环 Event Loop。 当调用setTimeout()方法时，浏览器内核相应模块开始延时方法的处理，当延时方法到达触发条件时，方法被添加到用于回调的任务队列，只要执行引擎栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些满足触发条件的回调函数。 参考文章：你真的了解setTimeout和setInterval吗?你所不知道的setIntervalTAT.ronnie【转向Javascript系列】从setTimeout说事件循环模型How JavaScript Timers Work","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"Math.random()随机数的一些事一些情","slug":"newone","date":"2016-11-05T00:55:29.000Z","updated":"2017-02-03T13:55:15.485Z","comments":true,"path":"2016/11/05/newone/","link":"","permalink":"http://yoursite.com/2016/11/05/newone/","excerpt":"","text":"Math.random()随机数的一些事一些情一、预备知识Math()12345678910111213141516Math.ceil(); //向上取整。Math.floor(); //向下取整。Math.round(); //四舍五入。Math.random(); //[0,1) 之间的一个伪随机数。Math.ceil(Math.random()*10); // 获取从1到10的随机整数 ，取0的概率极小。Math.round(Math.random()); //可均衡获取0到1的随机整数。Math.floor(Math.random()*10); //可均衡获取0到9的随机整数。Math.round(Math.random()*10); //基本均衡获取0到10的随机整数，其中获取最小值0和最大值10的几率少一半。//因为结果在0~0.4 为0，0.5到1.4为1...8.5到9.4为9，9.5到9.9为10。所以头尾的分布区间只有其他数字的一半。 Date()12345678var d = new Date();var n = d.getSeconds(); //生成0到59的随机数var n1 = d.getMilliseconds(); //生成0到999的随机数var n2 = d.getMilliseconds() % 201; //生成0到200的随机数//除了取 Date 的秒和微秒外，还可以取小时和分钟（跟取秒生成的随机数相同）。 String()1234567891011String.toString() //返回用字符串表示的特定对象String.substr(start[, length]) //返回字符串中从指定位置开始到指定长度的子字符串String.substring(indexStart[, indexEnd]) //返回字符串两个索引之间（或到字符串末尾）的子串String.slice(beginSlice[, endSlice]) //浅复制，提取字符串并返回新字符串RegExp字母ASCII码:A-65,a-97 二、应用 产生10个随机数 12345var arr = [],r;for(var i=0;i&lt;10;i++)&#123; r = (Math.random()/(new Date()-0)).toString(36).replace(/\\d/g,&apos;&apos;).slice(1); arr[i] ? (arr[i]+=1) : (arr[i]=r);&#125; 长度为5的随机数 123for (var c = &apos;&apos;; c.length &lt; 5;) &#123; c += Math.random().toString(36).substr(2,1)&#125; 利用字母ASCII码[65,97]，生成长度为x的随机数 123456789101112function rand(x) &#123; var s = &quot;&quot;; while (s.length &lt; x &amp;&amp; x &gt; 0) &#123; var r = Math.random(); s += String.fromCharCode(Math.floor(r * 26) + (r &gt; 0.5 ? 97 : 65)); &#125; return s;&#125;rand(x); 生成指定范围随机数 1234567891011121314151617Math.floor(Math.random() * (上限 - 下限 + 1) + 下限);Math.ceil(Math.random() * (上限 - 下限) + 下限);parseInt(Math.random() * (上限 - 下限 + 1) + 下限);//under：上限; over：下限; ceilfunction getRandom(under, over) &#123; switch (arguments.length) &#123; case 1: return Math.ceil(Math.random() * under); case 2: return Math.ceil(Math.random() * (over - under) + under); default: return 0; &#125;&#125; 随机背景色 1234567891011//方1&apos;#&apos;+(0x1000000+(Math.random())*0xffffff).toString(16).substr(1,6);//方2&quot;#&quot;+(&quot;000000&quot;+Math.floor(Math.random()*16777216).toString(16)).substr(-6);//方3function randomColor()&#123; var r=function()&#123;return Math.floor(Math.random()*256)&#125;; return &quot;rgb(&quot;+r()+&quot;,&quot;+r()+&quot;,&quot;+r()+&quot;)&quot;;&#125; 洗牌算法 123456789101112var i = 0, data = [], r;for (; i &lt; 10; data[i++] = i);while (--i) &#123; r = Math.round(Math.random() * 9 + 1) - 1; data[i] = data[i] + data[r], data[r] = data[i] - data[r], data[i] = data[i] - data[r];&#125;console.log(data) 或者利用Array.prototype.sort()函数，这里可以不把里面的数值带进来运算。 首先Math.random()会生成一个[0,1)之间的数值，用0.5这个比较公平的数值减去它，概率得到小于0，等于0,大于0三种状况，而Array.prototype.sort()期待的数值恰好是[-1,0,1]，是不是很省事。 1234567891011var i = 0, data = [], r;for (; i &lt; 10; data[i++] = i);data.sort(function() &#123; return .5 - Math.random();&#125;);","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"插入排序","slug":"six","date":"2016-11-05T00:55:29.000Z","updated":"2017-02-03T14:00:50.376Z","comments":true,"path":"2016/11/05/six/","link":"","permalink":"http://yoursite.com/2016/11/05/six/","excerpt":"","text":"算法原理：设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K3 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 Kn 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。 个人实现思路：1.设第一个elem( n=0 ) 已排好序A。2.从第二个elem( n=1 )开始，3.在找到准备插入的位置后，需要将该位置之后的数组元素往后挪一位； 所以，在对比之前，要先记录自身元素的值。4.【从后→前】对比，若 A[last] &gt; elem ,那么交换位置，直到 A[elem] &lt; elem ,本轮结束，elem已排好位置。5.重复步骤2-4，直至到达数组最后一位。 12345678910111213141516var arr = [1,3,9,6,5,2,7,2,3,4,8];function insertSort(arr)&#123; for(var i = 1; i &lt; arr.length; i++)&#123; var tmp = arr[i]; for( var j = i-1; j &gt; 0 , arr[j] &gt; tmp; j--)&#123; arr[ j+1 ] = arr[ j ]; arr[ j ] = tmp; &#125; console.log(arr); return arr;&#125;insertSort(arr);","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]}]}