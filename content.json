{"meta":{"title":"SammieHo's 学习慢炖","subtitle":null,"description":null,"author":"Sammieho","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-02-04T06:50:13.000Z","updated":"2017-02-05T14:19:47.056Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"tags","date":"2017-02-04T06:50:38.000Z","updated":"2017-02-05T14:19:59.604Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"String 总结与示例","slug":"String总结与示例","date":"2017-02-15T00:55:29.000Z","updated":"2017-02-15T01:56:25.149Z","comments":true,"path":"2017/02/15/String总结与示例/","link":"","permalink":"http://yoursite.com/2017/02/15/String总结与示例/","excerpt":"","text":"属性string.length 返回字符串的长度。 示例 12345var x = &quot;Mozilla&quot;;var empty = &quot;&quot;;console.log( x.length ); // 7console.log(empty.length); //0 String.prototype 所有 String 实例都继承于 String.prototype。 String.prototype 属性的属性特性：writable :falseenumerable :falseconfigurable :false 方法： 都不会改变原str var str = “abcd”, newS; 跟 HTML 无关的方法 方法 概述 示例 charAt(index) 返回指定索引的字符 str.charAt(0); // a charCodeAt(index) 返回指定索引的字符的Unicode编码，不存在/超出范围，返回NaN str.charCodeAt(0); // 97 (a的ASCII是97) concat(str) 将一/多个字符串与原字符串连接，返回新的字符串 newS = str.charAt(“e”,”f”); //newS = “abcdef”; str = “abcd” includes(searchString) 判断当前str是否包含searchString，返回T/F str.includes(“bc”); // true indexOf(searchVal) 返回指定值的第一次出现的索引 / -1。 str.indexOf(“bc”); // 1 lastIndexOf(searchVal) (从末尾开始搜索) 返回指定值的第一次出现的索引 / -1。 str.lastIndexOf(“”); // 2 repeat(count) 重复指定str，count次，返回新的字符串 str.repeat(1) //abcdabcd slice(begin,end) 提取部分str并返回 str.slice(0,1) //a split(“separator”) 将str按separator分割，并转化成arr str.split(“”) //[“a”,”b”,”c”,”d”]; substr(strat,len) 返回字符串中从指定位置开始到指定长度的子字符串。 str.substr(0,2); //“ab” substring(start,end) 返回字符串两个索引之间（或到字符串末尾）的子串。 str.substring(1,2); //“b” toLowerCase() 将str转换为小写并返回 str.toLowerCase(); //“abcd” toUpperCase() 将str转换为大写并返回 str.toUpperCase(); //“ABCD” trim() 删除str两端的空白字符(实际是replace) newS = “ a,cd “; newS.trim(); // “a,cd” toString() 返回字符串形式 str = [1,2,3];str.toString(); // “1,2,3” 与 RegExp 相关 方法 概述 返回值 示例 str.match(regexp) 字符串匹配到RegExp时，提取匹配项。 包含匹配结果的array / null str.match(/[a-z]/) // return [“a”] str.search(regexp) 查找str与一个RegExp是否匹配 返回首次匹配项的索引/ -1 str.search(/[a-z]/); // 0 replace(regexp/substr,newStr/function) 用arg2替换掉符合arg1的内容 返回替换后的新字符串 str.replace(/[a-b]/g,”N”); //“NNcd”","raw":null,"content":null,"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/categories/Javascript/"}],"tags":[]},{"title":"简单算法——Array与String的运用","slug":"简单算法——Array与String的运用","date":"2017-02-14T10:57:33.754Z","updated":"2017-02-15T02:42:16.570Z","comments":true,"path":"2017/02/14/简单算法——Array与String的运用/","link":"","permalink":"http://yoursite.com/2017/02/14/简单算法——Array与String的运用/","excerpt":"","text":"翻转字符串 思路：先把string转换成array，再借助数组的reverse翻转数组顺序，最后再把array转化为string 实现： 1234function reverseString(str)&#123; return str.split(&quot;&quot;).reverse().join(&quot;&quot;);&#125;reverseString(&quot;I&apos;m beaty!&quot;); 计算一个整数的阶乘 思路： 递归 累乘 实现： 12345678910111213141516171819202122231. 递归function factorialize(num)&#123; if(num === 0)&#123; return 1; &#125;else if( num &gt; 0 )&#123; return num*factorialize(num - 1); &#125;else&#123; alert(&quot;input right num.&quot;); &#125;&#125;factorialize(5); // 1202. 累乘function factorialize(num)&#123; if( num === 0 )&#123; return 1; &#125; for(var i = 1,multiply = 1; i &lt;= num; i++)&#123; multiply *= i; &#125; return multiply;&#125;factorialize(5); // 120 回文检测 规则：如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。 思路：先去掉标点符号，转换小写；再讲正向str与翻转后的str对比。 实现： 12345678910function palindrome(str)&#123; str = str.replace(/[\\W\\s_,]/g,&quot;&quot;).toLowerCase(); reverseStr = str.split(&quot;&quot;).reverse().join(&quot;&quot;); if(str === reverseStr)&#123; return &quot;true&quot;; &#125;else&#123; return &quot;false&quot;; &#125;&#125;palindrome(&quot;aabaa&quot;); 找到句子中最长的单词 思路：先去掉标点符号；再将string转化为数组,判断每个元素的长度。 实现： 1234567891011function findLongestWord(str)&#123; str = str.replace(/[_,.:!]/g,&quot;&quot;).split(&quot; &quot;); var len = 0; for(var i = 0; i &lt; str.length; i++)&#123; if(str[i].length &gt; len )&#123; len = str[i].length; &#125; &#125; return len;&#125;findLongestWord(&quot;The quick brown fox jumped over the lazy dogaaaa.&quot;); 首字母大写 思路：1将string全部小写后转化为数组，数组每一个元素的第一个子元素大写。 实现： 12345678910111213141516171819202122232425261. 先全部字符转化为小写，再分割成数组，用map迭代数组，用replace替换数组每个元素的首字母function titleCase1(str)&#123; return str.toLowerCase().split(&quot; &quot;).map(function(val)&#123; return val.replace(val.charAt(0),val.charAt(0).toUpperCase()); &#125;).join(&quot; &quot;);&#125;2. for in 遍历function titleCase2(str)&#123; str = str.toLowerCase().split(&quot; &quot;); for(var val in str )&#123; str[val] = str[val].replace(str[val].charAt(0),str[val].charAt(0).toUpperCase()); &#125; return str.join(&quot; &quot;);&#125;3. 正则匹配每一个子字符串(\\w 匹配字母或数字或下划线或汉字；\\s 匹配任意非空白符)，对每个val进行替换function titleCase3(str)&#123; return str.replace(/\\w\\S*/g,function(val)&#123; return val.charAt(0).toUpperCase() + val.slice(1).toLowerCase(); &#125;);&#125;titleCase(&quot;I&apos;m a little tea pot.&quot;); 找出大数组中每个小数组的最大值 思路：给每个小数组排序，将每个小数组的第一元素串联，形成新数组。 实现： 1234567891011function largestOfArr(arr)&#123; var str = []; for(var i = 0; i &lt; arr.length; i ++)&#123; arr[i].sort(function(a,b)&#123; return b-a; &#125;); str.push(arr[i][0]); &#125; return str;&#125;largestOfArr([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); 检查指定的字符串结尾 思路：检查一个字符串(str)是否以指定的字符串(target)结尾。如果是，返回true;如果不是，返回false。 实现： 1234567function confirmEnding(str,target)&#123; if(str.slice( target.length*(-1)) === target)&#123; return &quot;true&quot;; &#125;else&#123; return &quot;false&quot;; &#125;&#125; 重复字符串 思路：重复制定的字符创 num 次，如果 num 为负则返回空字符创。 实现： 123456789101112131415161718191. 初始想法function repeatStr(str,num)&#123; var newStr = &quot;&quot;; if( num === 0)&#123; return &quot; &quot;; &#125; while(num &gt; 0)&#123; newStr += str; num--; &#125; return newStr;&#125;2. 用String.prototype.repeat()function repeatStr(str,num)&#123; return str.repeat(num);&#125;repeatStr(&quot;aa,&quot;,3); //&quot;aa,aa,aa,&quot; 截断一个字符串 规则：如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。 切记，插入到字符串尾部的三个点号也会计入字符串的长度。 但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 思路： 对比字符串strLen与参数num； strLen &gt; num ,截断str范围(0,num-3]，加”…” strLen &lt;= 3,不截断，直接加“…” 实现： 123456789101112function truncate(str, num) &#123; // Clear out that junk in your trunk if( str.length &gt; num &amp;&amp; num &gt; 3)&#123; str = str.substr(0, num - 3) + &quot;...&quot;; &#125;else if( str.length &lt;= num)&#123; str = str; &#125; else&#123; str = str.slice(0, num ) + &quot;...&quot;; &#125; return str;&#125; 按制定size分割数组 思路：把一个数组arr按照指定的数组大小size分割成若干个数组块。 Array.push();Array.slice(); 例如:chunk([1,2,3,4],2)=[[1,2],[3,4]]; chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]; 实现： 123456789function chunk(arr, size) &#123; var newArr = []; for( var i = 0; i &lt; arr.length; i += size)&#123; newArr.push(arr.slice(i,i+size)); &#125; return newArr;&#125;chunk([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], 2); 返回被截断的元素 规则：返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。 实现：Array.splice()的应用。 123456function slasher(arr, howMany)&#123; arr.splice(0, howMany);//返回被删除的元素组成的数组 return arr;&#125;slasher([1, 2, 3], 2); 删除数组中的所有假值 思路：假值有false、null、0、””、undefined 和 NaN。Boolean ObjectsArray.filter() 实现： 123456789101112function bouncer(arr) &#123; // Don&apos;t show a false ID to this bouncer. var newArr = arr.filter(function(val)&#123; var x = new Boolean(val); if( x )&#123; return val; &#125; &#125;); return newArr;&#125;bouncer([7, &quot;ate&quot;, &quot;&quot;, false, 9]); 摧毁函数 规则：第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 思路： 将除第一个参数意外的参数连接成数组comp； 过滤，当第一个参数的元素不存在于comp时，符合返回。 Array.filter();Arguments object 实现： 1234567891011121314151617181920212223242526272829301. 初始做法function destroyer(arr) &#123; // Remove all the values var compareArgs = [].slice.call(arguments,1); var newArr = arr.filter(function(val)&#123; var len = compareArgs.length; for(var i = 0;i &lt; len; i++)&#123; if( val == compareArgs[i])&#123; return false; &#125;else if( val != compareArgs[i] &amp;&amp; i == len - 1 )&#123; return val; &#125; &#125; &#125;); return newArr;&#125;2. 优化后function des(arr)&#123; var comp = Array.prototype.slice.call(arguments,1); return arr.filter(function(val)&#123; if( comp.indexOf(val) &lt; 0 )&#123; return val; &#125; &#125;);&#125;des([1, 2, 3,5, 1, 2, 3], 2, 3); 找到指定的值在数组的位置 思路：先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 实现： 123456789101112131415161718192021222324252627281. Firstfunction where(arr, num) &#123; // Find my place in this sorted array. arr.sort(function(a,b)&#123; return a-b; &#125;); var i = 0; while( arr[i] &lt; num)&#123; i++; &#125; return i;&#125;2. twofunction whe(arr, num)&#123; arr.sort(); for(var i = 0; i &lt; arr.length; i++)&#123; if( arr[i] &gt; num )&#123; return i; &#125; &#125; return arr.length;&#125;whe([70, 60], 80); 凯撒密码 思路：右移13位 实现： 12345678910111213141516171819function rot13(str) &#123; // LBH QVQ VG! str = str.split(&quot;&quot;); var newStr = str.reduce(function(preVal,curVal)&#123; if( curVal.match(/[A-Z]/) !== null )&#123; curVal = curVal.charCodeAt(0) + 13; if( curVal &gt; 90 )&#123; curVal -= 26; &#125; return preVal += String.fromCharCode(curVal); &#125; else&#123; return preVal += curVal; &#125; &#125;,&quot;&quot;); return newStr;&#125;rot13(&quot;SERR CVMMN!&quot;);","raw":null,"content":null,"categories":[{"name":"Array String Javascript","slug":"Array-String-Javascript","permalink":"http://yoursite.com/categories/Array-String-Javascript/"}],"tags":[]},{"title":"Array 总结与示例","slug":"Array总结与示例","date":"2017-02-13T14:06:30.484Z","updated":"2017-02-14T00:21:15.738Z","comments":true,"path":"2017/02/13/Array总结与示例/","link":"","permalink":"http://yoursite.com/2017/02/13/Array总结与示例/","excerpt":"","text":"属性array.length 返回一个数组中的元素个数。 Array.length 属性的属性特性：writable :trueenumerable :falseconfigurable :false 示例 12345var items = [&quot;shoes&quot;, &quot;shirts&quot;, &quot;socks&quot;, &quot;sweaters&quot;];items.length;// 返回 4 Array.prototype 所有的数组实例都继承于 Array.prototype。 Array.prototype 属性的属性特性：writable :falseenumerable :falseconfigurable :false 注意：Array.prototype 本身是个空数组。 1Array.isArray(Array.prototype) //true 所有的数组方法都是定义在Array.prototype上，通过扩展其属性的方法来给所有数组示例增加方法。(构造函数的方式) 方法：① 会改变自身 方法 概述 返回值 示例 sort(compareFunction) 排序 新数组 array.sort(func); push(ele1,ele2,ele3) 在末尾添加元素 数组的新长度 let a = [1,2]; a.push(3,4) // return 4 pop() 删除末尾的元素 返回该元素的值,会更改数组的长度 let a = [1,2,3]; a.pop();//return 3 unshift(ele1,ele2,ele3) 在头部添加元素 数组的新长度 类似push() shift() 在头部删除元素 被删除元素的值 类似pop() reverse() 翻转数组 返回该数组的引用 array.reverse() splice(start, delCount, item1, …) 添加/删除特定元素 被删除元素组成的数组 a.splice(2,0,”aa”) ② 不会改变原数组 var a = [“a”,”b”,”c”],newA; 方法 概述 示例 concat(arr1,arr2) 连接 a.concat(“d”); //[“a”,”b”,”c”,”d”] includes(num) 判断当前数组是否包含某指定的值,返回true/false a.includes(“b”); //true indexOf(ele) 返回数组中存在元素的第一个索引，没有则返回-1 a.indexOf(“b”); //1 lastIndexOf(ele) 与indexOf类似，不过从末尾开始寻找 a.lastIndexOf(“b”) // 1 join(“,”) 把数组按”,”连接成string newA = a.join(“-“); //return a-b-c slice(begin,end) 部分浅拷贝, 返回到从开始到结束（半开半闭区间）选择的新数组对象 newA = a.slice(1,2); // newA = [“b”]; toString() 返回一个字符串,由”,”连接 newA = a.toString(); // “a,b,c” ③ 遍历方法 方法 概述 callback forEach() 排序 function(val){return val;} filter() 过滤出符合条件的元素，callback的参数作为当前迭代的项，返回true的项保留，false过滤。 function(val) map() 根据callback来处理每个元素 function(val) reduce(func,per(选)) 迭代数组，并累计到一个值中。callback是个累加器 function(preVal,curVal) every(callback[, thisArg]) 每个元素都符合callback，返回T/F func(element, index, array) some() 其中一个符合callback，返回T/F callback 被调用时传入三个参数：元素的值，元素的索引，被遍历的数组。 find() 返回数组中满足提供的测试函数的第一个元素的值,无则undefined findIndex() 返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。","raw":null,"content":null,"categories":[{"name":"Array","slug":"Array","permalink":"http://yoursite.com/categories/Array/"}],"tags":[]},{"title":"JSON发送数据","slug":"JSON发送数据","date":"2017-02-05T06:27:25.937Z","updated":"2017-02-05T08:27:16.926Z","comments":true,"path":"2017/02/05/JSON发送数据/","link":"","permalink":"http://yoursite.com/2017/02/05/JSON发送数据/","excerpt":"","text":"JavaScript 对象表示法 “键名”:”值” 例子：12345&#123; &quot;banner&quot;: &quot;2&quot;, &quot;apples&quot;: &quot;3&quot;, &quot;cherries&quot; &quot;20&quot;&#125;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Ajax 的 深入学习","slug":"ajaxNote","date":"2017-02-05T03:04:15.030Z","updated":"2017-02-14T00:21:27.420Z","comments":true,"path":"2017/02/05/ajaxNote/","link":"","permalink":"http://yoursite.com/2017/02/05/ajaxNote/","excerpt":"","text":"Ajax 起步 创建一个新的XMLHttpRequest 对象 1var httpRequest = new XMLHttpRequest(); 给 readystatechange 事件设置一个事件处理器handlerResponse 1httpRequest.onreadystatechange = handlerResponse; 然后，告诉 XMLHttpRequest 对象你想要做什么： 使用 open 方法来指定 HTTP 方法和需要请求的URL 1httpRequest.open( &quot;get&quot;, e.target.innerHTML + &quot;.html&quot; ); 调用send() 方法，向服务器发送数据 1httpRequest.send(); HTTP 方法： GET：适合安全的交互行为，那些可以反复发起而不会带来副作用的请求。 POST：适合不安全的交互行为，每一个请求都会导致服务器端发生变化，而重复的请求可能会带来问题。 处理响应一旦脚本调用了send方法，浏览器在后台发送请求到服务器，而 Ajax 依靠时间来通知请求的进展。 此处用 handlerResponse 来处理这些事件：12345function handlerResponse(e)&#123; if( e.target.reayState == XMLHttpRequest.DONE &amp;&amp; e.target.status == 200)&#123; document.getElementById(&quot;target&quot;).innerHTML = e.target.responseText; &#125;&#125; DONE状态并不意味着请求成功，只代表请求已完成。通过status属性获得HTTP状态码，会返回一个数值（例如200表示成功）。只有结合 readyState 和 status 属性的值才能够 确定请求的结果。用 XMLHttpRequest.responseText 属性获得服务器发送的数据。 XMLHttpRequest readyState 属性的值 值 数值 状态说明 UNSENT 0 已创建XMLHttpRequest对象，请求未初始化，open未调用； OPENED 1 Server链接已建立，open已调用； HEADERS_RECEIVED 2 已收到服务器响应的标头 LOADING 3 请求处理中，已收到服务器响应 DONE 4 响应完成或已失败。 HTTP 状态码 状态码 说明 1xx： 信息类。表示接受到浏览器请求，进一步处理。 2xx： 成功。请求被正确接收，理解和处理。 3xx： 重定向。请求失败，客户采取进一步操作。 4xx： 客户端错误。 5xx： 服务器错误。服务器不能完成请求。 完整代码如下// 用户点击一个按钮， // 浏览器在后台向服务器请求一个文档， // 当它到达时处理一个事件，并显示被请求文档的内容。 var btn = document.getElementsByTagName(&apos;button&apos;); var tar = document.getElementById(&quot;target&quot;); for(let i = 0; i &lt; btn.length; i++){ btn[i].onclick = handlerBtnPress; } function handlerBtnPress(e){ var httpRequest = new XMLHttpRequest(); httpRequest.open( &quot;GET&quot;, e.target.innerHTML + &quot;.html&quot;); httpRequest.onreadystatechange = handlerResponse; httpRequest.send(); } function handlerResponse(e){ if(e.target.readyState === 4 &amp;&amp; e.target.status === 200){ tar.innerHTML = e.target.responseText; } } 兼容 Opera Queation 1： Opera 在出发readystatechange事件时不会生成一个Event对象。 Resolve： 把XMLHttpRequest对象指派给一个全局变量。 123456789101112131415var httpRequest;function handlerBtnPress(e)&#123; httpRequest = new XMLHttpRequest(); httpRequest.open( &quot;GET&quot;, e.target.innerHTML + &quot;.html&quot;); httpRequest.onreadystatechange = handlerResponse; httpRequest.send();&#125;function handlerResponse(e)&#123; if(httpRequest.readyState === 4 &amp;&amp; httpRequest.status === 200)&#123; tar.innerHTML = httpRequest.responseText; &#125;&#125; 使用 Ajax 事件XMLHttpRequest 对象定义的事件 名称 说明 事件类型 abort 在请求被终止时触发 ProgressEvent error 在请求是被时触发 ProgressEvent load 请求成功完成时触发 ProgressEvent loadend 请求已完成时触发，无论成功还是发生错误 ProgressEvent loadstart 请求开始时触发 ProgressEvent progress 触发以提示请求的进度 ProgressEvent readystatechange 在请求生命周期的不同阶段触发 Event timeout 请求超时则触发 ProgressEvent ####ProgressEvent 定义的额外属性 名称 说明 事件类型 lengthComputable 如果能够计算数据流的总长度则返回true boolean loaded 返回当前已载入的数据量 number total 返回可用的数据总量 number 使用XMLHttpRequest定义的一次性事件 这是之前示例的一种变量，为一些事件注册了处理函数，并在一个table内为处理的时间创建了记录，以看清楚浏览器是如何处罚这些事件的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var btn = document.getElementsByTagName('button');var tar = document.getElementById(\"target\");var eve = document.getElementById(\"eve\");var httpRequest;for(var i = 0; i &lt; btn.length; i++)&#123; btn[i].onclick = handlerBtnPress;&#125;function handlerBtnPress(e)&#123; clearEveDetails(); httpRequest = new XMLHttpRequest(); httpRequest.onreadystatechange = handlerResponse; httpRequest.onerror = handlerError; httpRequest.onload = handlerLoad; httpRequest.onloadstart = handlerLoadstart; httpRequest.onloadend = handlerLoadend; httpRequest.onprogress = handlerProgress; httpRequest.open( \"GET\", e.target.innerHTML + \".html\"); httpRequest.send();&#125;function handlerResponse(e)&#123; displayEveDetails(\"readystate(\" + httpRequest.readyState + \")\"); if(httpRequest.readyState === 4 &amp;&amp; httpRequest.status === 200)&#123; tar.innerHTML = httpRequest.responseText; &#125;&#125;function handlerError(e)&#123; displayEveDetails(\"error\",e); &#125;function handlerLoad(e)&#123; displayEveDetails(\"load\",e); &#125;function handlerLoadstart(e)&#123; displayEveDetails(\"loadstart\",e); &#125;function handlerLoadend(e)&#123; displayEveDetails(\"loadend\",e); &#125;function handlerProgress(e)&#123; displayEveDetails(\"progress\",e); &#125;function clearEveDetails(e)&#123; eve.innerHTML = \"&lt;tr&gt;&lt;th&gt;Event&lt;/th&gt;&lt;th&gt;lengthComputable&lt;/th&gt;&lt;th&gt;loaded&lt;/th&gt;&lt;th&gt;total&lt;/th&gt;&lt;/tr&gt;\";&#125;function displayEveDetails(eventName,e)&#123; if(e)&#123; eve.innerHTML += \"&lt;tr&gt;&lt;td&gt;\" + eventName + \"&lt;/td&gt;&lt;td&gt;\" + e.lengthComputable + \"&lt;/td&gt;&lt;td&gt;\" + e.loaded + \"&lt;/td&gt;&lt;td&gt;\" + e.total + \"&lt;/td&gt;&lt;/tr&gt;\"; &#125;else&#123; eve.innerHTML += \"&lt;tr&gt;&lt;td&gt;\" + eventName + \"&lt;/td&gt;&lt;td&gt;\" + \"NAN\" + \"&lt;/td&gt;&lt;td&gt;\" + \"NAN\" + \"&lt;/td&gt;&lt;td&gt;\" + \"NAN\" + \"&lt;/td&gt;&lt;/tr&gt;\" &#125;&#125; 生成 Ajax 跨域请求浏览器为防止跨站脚本攻击，采用的同源策略，即 协议、主机名、端口号一致。 ####CORS 跨源资源共享 Cross-origin-resource-sharing通过添加跨源表头 Access-Control-Allow-Origin，指定某个来源必须被允许对此文档生成跨域请求。","raw":null,"content":null,"categories":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/categories/Ajax/"}],"tags":[]},{"title":"区别 client,page,offset,screen","slug":"ten","date":"2017-02-04T08:36:08.133Z","updated":"2017-02-04T09:10:13.697Z","comments":true,"path":"2017/02/04/ten/","link":"","permalink":"http://yoursite.com/2017/02/04/ten/","excerpt":"","text":"client 客户区坐标位置顾名思义，相对于 浏览器内容区域 视口 而言的clientX，clientY （不包含页面滚动的距离） 图示如下： screen 屏幕坐标位置相对于 整个显示器的屏幕而言的 screenX，screenY 图示如下： page，offset 页面坐标位置相对于整个网页，是算上滚动条的。 例如：网页的 width：980px; height: 3000px;那么 page 和 offset 的最大值就是 980 和 3000。 而 page 和 offset 的区别就是：IE8以下只支持offset。 图示如下： 参考资料-《Javascript高程》","raw":null,"content":null,"categories":[],"tags":[]},{"title":"事件监听—addEventListener","slug":"for","date":"2017-02-03T13:57:39.729Z","updated":"2017-02-03T13:58:36.002Z","comments":true,"path":"2017/02/03/for/","link":"","permalink":"http://yoursite.com/2017/02/03/for/","excerpt":"","text":"123elementObj.addEventListener(type,listener,useCapture);当监听对象触发指定的事件后，执行指定回调函数。 addEventListener相对于attachEvent优点： 一个事件可注册多个listener。 Listener的触发可以选择capture/bubbling。 对任何DOM元素都有效。 在内存问题上，使用预先声明的函数，比匿名函数的消耗更小。 移除指定的事件： 1removeEventListener(event,function,capture/bubble); event.target 在处理事件时会被用到，例如：12345function hide(event)&#123; var target = event.target || event.srcElement;//target兼容处理 event.target.style.display = &apos;none&apos;;&#125;obj.addEventListener(&apos;click&apos;,hide,false); 兼容：123456789101112131415function addEvent(obj,type,func)&#123; if(window.addEventListener)&#123; obj.addEventListener(type,func,false); &#125; else&#123; obj.addEventListener(&apos;on&apos;+type,func); &#125;&#125;or:function addEvent(obj,type,listener)&#123; obj.addEventListener? obj.addEventListener(type,func,false) : obj.addEventListener(&apos;on&apos;+type,func); return obj;&#125;","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"一道关于this和作用域的题目引发的思考","slug":"night","date":"2017-01-23T00:55:29.000Z","updated":"2017-02-03T14:03:08.895Z","comments":true,"path":"2017/01/23/night/","link":"","permalink":"http://yoursite.com/2017/01/23/night/","excerpt":"","text":"题目引发思考： 一天在freecodecamp的群里，讨论到this的问题，最后有一道这样的题目: 123456789101112131415161718var name = 'global';var A = &#123; name: 'obj', test: function()&#123; var name = 'gaga'; this.name = 'dose'; return function()&#123; console.log(name); return this.name; &#125;; &#125;&#125;;var B = A.test;console.log( A.test()() );console.log( B()() ); 我的初始答案是这样：gaga,dosegaga,global然而是错的…/(ㄒoㄒ)/~~ 我百思不得其解，为什么会这样呢？再想了一遍，思维很混乱，开始怀疑人生（抖腿）。 第二天起来，脑海一直浮现一句话： this 是在函数调用时才指定的！ this 是在函数调用时才指定的！ this 是在函数调用时才指定的！ 尝试：**为了理清思路，找到 this 的指向，我做了一些尝试： 12345** 最后得出：**A.test() 实际上调用了 foo() , this 的隐式绑定，指向 A 内部。所以 this.name = &quot;dose&quot; 是给 A.name 赋值。A.test()() 返回匿名函数，默认指向全局，此时 this.name 就是 window.name，输出 &quot;global&quot;。B() 实际等于全局的 foo()，此时 foo 内的 this 指向 window ，this.name 等于给 window.name 赋值，所以 B()()返回 &quot;dose&quot; 借此题重温this的机制： this是在运行时进行绑定的，他的绑定与函数声明的位置没有关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动对象（执行上下文），这个记录会包含函数在哪里被调用、函数的调用方式、传入的参数等信息，this就是这个记录的一个属性，会在函数执行过程中用到。 this的绑定规则： new 显示绑定 隐式绑定 默认绑定 this的好：可以在不同的上下文对象中重复使用函数，不用针对每个对象编写不同版本的函数。 举个栗子：12345678910111213141516171819202122function identify()&#123; return this.name.toUpperCase();&#125;function speak()&#123; var greet = \"Hello,\" + identify.call( this ); console.log( greet );&#125;var me = &#123; name: \"Kyle\"&#125;;var you =&#123; name: \"Read\"&#125;;console.log( identify.call( me ) );console.log( identify.call( you ) );speak.call( me );speak.call( you ); Conclusion:函数可以自动引用合适的上下文。this 提供了一种更优雅的方式来隐式“传递”一个对象饮用，因此可以将API设计得更加简洁和易于复用。 最后谨记！ this是在函数调用时才指定的。 作用域是在写函数的时候已经确定了。","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"从柯里化函数，加深对递归的运用","slug":"seven","date":"2016-11-20T00:55:29.000Z","updated":"2017-02-03T14:01:22.886Z","comments":true,"path":"2016/11/20/seven/","link":"","permalink":"http://yoursite.com/2016/11/20/seven/","excerpt":"","text":"遇到过这么一道面试题 写出函数，实现 sum(2)(3) , sum(2,3) 当时我是这么写的：12345678910function sum(a)&#123; if(arguments.length == 2)&#123; return arguments[0] + arguments[1]; &#125; else&#123; return function (b)&#123; return a + b; &#125; &#125;&#125; 然后我就想不会这么简单吧吧吧吧吧吧吧！！应该是要写n个参数，或者回调的情况下的通用函数，最后，我就画画画，没写出来，还搞到答卷“花面猫”似的。 回来，我搜索了一下，涉及到curry，柯里化函数。我懵逼了，这素啥。原来是递归的原理，分次接收参数。嗯，我要的就是这效果。 下面是实现 123456789101112131415161718192021222324252627282930313233function curry(fn,curryArgs)&#123; return function()&#123; var args = Array.prototype.slice.call(arguments,0); // 首次调用时未提供最后一个参数 if(curryArgs !== undefined)&#123; args = args.concat(curryArgs); &#125; // 递归边界 if( !arguments.length )&#123; return fn.apply(null, args); &#125; else&#123; return curry(fn, args); &#125; &#125;&#125;function sumOf()&#123; var total = 0; for(var i=0; i&lt;arguments.length; i++)&#123; total += arguments[i]; &#125; return total;&#125;// 改造普通函数，返回柯里函数var sum = curry(sumOf);sum(2, 3)(1)(1)(1, 2, 3)(); 另一个方法：1234567891011121314151617181920212223242526272829303132function add() &#123; var total = 0; if (arguments.length) &#123; var arr1 = Array.prototype.slice.call(arguments); var mytotal = arrayAdder(arr1); return sum(mytotal); &#125; else &#123; return sum(); &#125; function sum() &#123; if (arguments.length) &#123; var arr = Array.prototype.slice.call(arguments); total = total + arrayAdder(arr); return sum; &#125; else &#123; return total; &#125; &#125; function arrayAdder(arr) &#123; var x = 0; for (var i = 0; i &lt; arr.length; i++) &#123; x = x + arr[i]; &#125;; return x; &#125;&#125;add(2, 3)(1)(1)(1, 2, 3)(); 最后一点！很重要！上面的解决方法是我参考了别人的文章/回答，总结下来的，若涉及到版权问题，请联系我删除，抱歉。目前，未能深入理解柯里化函数，我会在接下来继续思考。 参考文章： 从 sum(2)(3) == sum(2, 3) 到实现柯里化函数 JS中的柯里化(currying) JavaScript的柯里化函数 浅析 JavaScript 中的 函数 currying 柯里化 js 函数式编程之函数柯里化 另外一个方法式在stackflow 找到的回答。","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"快速排序","slug":"five","date":"2016-11-11T00:55:29.000Z","updated":"2017-02-03T14:00:13.425Z","comments":true,"path":"2016/11/11/five/","link":"","permalink":"http://yoursite.com/2016/11/11/five/","excerpt":"","text":"思路 选一基准元素 point 分区操作(partition)：小于point放左边，大于point放右边，point最后的位置就是排序完成的位置。 重复步骤1.2 123456789101112131415161718192021222324252627282930313233343536373839404142function quickSort(array) &#123; //交换元素位置 function swap(arr, i, k) &#123; var temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; //分区操作，左小右大 function partition(arr, left, right) &#123; var sortIndex = left; var point = arr[right];//直接选最右的作为基准元素 for (var i = left; i &lt; right; i++) &#123; if (arr[i] &lt;= point) &#123; swap(arr, i, sortIndex); sortIndex++; &#125; &#125; swap(arr, sortIndex, right);//将基准元素放置在最后的正确位置 //console.log(arr); return sortIndex; &#125; function sort(arr, left, right) &#123; if (left &gt; right) &#123; return; &#125; var sortIndex = partition(arr, left, right); sort(arr,left,sortIndex-1); sort(arr, sortIndex + 1, right); &#125; sort(arr, 0, arr.length - 1); return array;&#125;quickSort(arr); 算法分析 快速排序的时间主要耗费在划分操作上，对长度为 k 的区间进行划分，共需 k-1 次关键字的比较。 最坏时间复杂度 最坏情况是每次划分选取的基准都是当前无序区中关键字最小(或最大)的记录，划分的结果是基准左边的子区间为空(或右边的子区间为空)， 而划分所得的另一个非空的子区间中记录数目，仅仅比划分前的无序区中记录个数减少一个。 因此，快速排序必须做 n-1 次划分， 第i次划分开始时区间长度为 n-i+1，所需的比较次数为 n-i(1≤i≤n-1)，故总的比较次数达到最大值：Cmax = n(n-1)/2=O(n^2) 如果按上面给出的划分算法，每次取当前无序区的第 1 个记录为基准，那么当文件的记录已按递增序(或递减序)排列时， 每次划分所取的基准就是当前无序区中关键字最小(或最大)的记录，则快速排序所需的比较次数反而最多。 最好时间复杂度 在最好情况下，每次划分所取的基准都是当前无序区的”中值”记录，划分的结果是基准的左、右两个无序子区间的长度大致相等。 总的关键字比较次数：O(nlgn) 注意： 用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为 O(lgn)， 而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数 C(n)=O(nlgn)。 因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为 O(n^2)，最好时间复杂度为 O(nlgn)。 平均时间复杂度 尽管快速排序的最坏时间为 O(n^2)，但就平均性能而言，它是基于关键字比较的内部排序算法中速度最快者，快速排序亦因此而得名。 它的平均时间复杂度为 O(nlgn)。 基准关键字的选取 在当前无序区中选取划分的基准关键字是决定算法性能的关键。 ”三者取中”的规则 “三者取中”规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准， 在划分开始前将该基准记录和该区伺的第1个记录进行交换，此后的划分过程与上面所给的 Partition 算法完全相同。 取位于 low 和 high 之间的随机数k(low≤k≤high)，用 R[k] 作为基准 选取基准最好的方法是用一个随机函数产生一个取位于 low 和 high 之间的随机数 k(low≤k≤high)，用 R[k] 作为基准， 这相当于强迫R[low..high]中的记录是随机分布的。用此方法所得到的快速排序一般称为随机的快速排序。 注意： 随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件， 一般不可能导致最坏情况的发生。算法的随机化不仅仅适用于快速排序，也适用于其它需要数据随机分布的算法。 空间复杂度 快速排序在系统内部需要一个栈来实现递归。若每次划分较为均匀，则其递归树的高度为 O(lgn)，故递归后需栈空间为 O(lgn)。 最坏情况下，递归树的高度为 O(n)，所需的栈空间为 O(n)。 参考文章 常见排序算法 - 快速排序 (Quick Sort) 理解快速排序算法","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"Ajax 笔记","slug":"eight","date":"2016-11-11T00:55:29.000Z","updated":"2017-02-03T14:02:18.334Z","comments":true,"path":"2016/11/11/eight/","link":"","permalink":"http://yoursite.com/2016/11/11/eight/","excerpt":"","text":"工作原理创建 和 Code 创建XMLHttpRequest()对象； 创建HTTP请求，链接服务器，设置请求动作FET/POST，URL，异步/同步； 发送HTTP请求；（三次握手四次挥手） 设置响应状态变化时间onreadystatechange； 接受返回数据(responseText,readyState,status等)； 使用Javascript DOM 操作，实现局部刷新。 1234567891011121314151617181920function ajaxDemo()&#123; var objXml; if(window.XMLHttpRequest)&#123; objXml = new XMLHttpRequest(); &#125; else&#123; objXml = ActiveXObject(&quot;Microsoft.XMLHttp&quot;); &#125; objXml.open(&apos;get&apos;,&apos;demo.php&apos;,true); objXml.onreadystatechange = function()&#123; if(objXml.readyState == 2 &amp;&amp; objXml.status ==200)&#123; //do something... &#125; &#125; objXml.send();&#125; XHR对象属性 属性 描述 onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML: 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） statusText 伴随状态码的字符串信息 readyState的返回值 返回值 状态说明 0： 请求未初始化，open未调用； 1： Server链接已建立，open已调用； 2： 请求已接收，接收到头信息了； 3： 请求处理中，接收到响应主体了； 4： 请求已完成，且响应已就绪 =&gt; 响应完成了。 HTTP 状态码 状态码 说明 1xx： 信息类。表示接受到浏览器请求，进一步处理。 2xx： 成功。请求被正确接收，理解和处理。 3xx： 重定向。请求失败，客户采取进一步操作。 4xx： 客户端错误。 5xx： 服务器错误。服务器不能完成请求。 XHR对象方法 方法 描述 abort() 导致当前正在执行的请求被取消 getAllResponseHeaders() 返回包含所有响应头的名称和值的单个字符 getResponseHeader(name) 返回响应头中指定的名称和值 open(method,url,async,username,pwd) 设置HTTP方法（get或post）等 send(content) 发出带有指定主体内容的请求 setRequestHeader(name,value); 使用指定的名称和值设置请求头 Ajax 的 优缺点Ajax的优点传统Ajax的问题 可以无刷新改变页面内容，但无法改变页面URL。 改变URL 的hash不能很好的处理浏览器的前后，后退问题。 解决方法补充内容 GET 与 POST 异步 与 同步 三次握手四次挥手 参考内容 JavaScript学习总结（七）Ajax和Http状态字 Javascript 高级编程（第三版）","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"重新认识-盒子模型","slug":"newthr","date":"2016-11-08T00:55:29.000Z","updated":"2017-02-03T13:56:41.010Z","comments":true,"path":"2016/11/08/newthr/","link":"","permalink":"http://yoursite.com/2016/11/08/newthr/","excerpt":"","text":"最近被问到盒子模型，却发现自己顿了一下，会用，却说不出个所以然。这就是基础知识不扎实的漏洞！！！所以，以最短的语言自我归纳了n遍！ 首先，什么是盒子模型？简单来说，就是元素大小的呈现方式。有一句话这么说来着 “every element in web design is a rectangular box.” 每个盒子有四条边界：1外边距边界margin edge + 边框边界 border edge + 内边距边界padding edge + 内容边界content edge. 然后有两种模式：123标准盒模型：content width 和 content height 只包含内容的宽/高，不包含padding,border,margin。IE6- 怪异模式：content width 与 content height 包括 padding 和 border，不包括 margin。 好，预（hu）备（shuo）知（ba）识（dao）说完，进入运用。 Box-sizing用来改变CSS盒模型对元素宽高的计算方式。 语法：-moz-box-sizing | box-sizing : content-box | border-box | padding-box ; 值：12content-box : 默认值，标准盒模型。实际width = content width + padding + border + margin 123border-box : IE6- 怪异模式实际width = 内容的宽 (包含 padding-left + padding-right + border-left + border-right) + margin margin叠加123发生在普通文档流中块元素的垂直方向外边距，此时外边框高度取两者间较大的那个，行内框、 浮动框或绝对定位框之间的外边距不会叠加。","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"setTimeout()和setInterval()的单细胞感情","slug":"newtwo","date":"2016-11-06T00:55:29.000Z","updated":"2017-02-03T13:56:04.935Z","comments":true,"path":"2016/11/06/newtwo/","link":"","permalink":"http://yoursite.com/2016/11/06/newtwo/","excerpt":"","text":"一、简单的语法与浅层的区别语法：12var setT= window.setTimeout(func/code,delay);var setI = window.setInterval(func/code,delay); 嗯，基本上是一样的，相对还有clearTimeout(setT)和clearInterval(setI)。 当第二个参数delay缺省时，默认为0 当指定的值小于4毫秒，则增加到4ms（4ms是HTML5标准指定的，对于2010年及之前的浏览器则是10ms） 区别： setTimeout() 延时，只执行一次 setInterval() 每隔一段时间，循环执行。 一点点题外话，setTimeout递归调用自己~是可以模拟setInterval滴。12345var setT = setTimeout(ourself(),100);function ourself()&#123; /*code*/ setTimeout(ourself(),100);&#125; 二、定时器与线程的一些事情先讲讲Javascript的工作方式，不然后面就聊不下去咯~1. Javascript是单线程的 每个window执行一个js线程，在某个特定时刻只有特定的代码块能够执行，其他代码块被阻塞（后来的要排队是中华人民共和国的传统美德）。 因为Javascript的作用是 进行 交互 和 DOM操作，如果JS是多线程，那么试想一下一个线程在修改节点的内容，另一个线程要删除这个节点，那么，是修改还是删除？不知道。所以，为了避免复杂性，JS是单线程的。 2.通过回调函数进行异步 异步，就是当B等待A时，B去干别的事，当有通知时（即被告知A已完成时）B再去做该做的，而通知通过回调函数来完成。耗时几乎可忽略不计。例如鼠标点击，定时器触发，或者一个XMLHttpRequest完成等 3.不靠谱的setInterval 1234567891011121314151617181920function formatDate()&#123; //code...&#125;var timer, i = 0;function test()&#123; dateStart = new Date(); timer = setInterval(function()&#123; i++; console.log(&apos;Interval&apos; + i); &#125;,8000); for(var i = 0;i &lt; 5; i++)&#123; formatDate(dateStart); //5 second while( new Date() - dateStart &lt; 5*1000 )&#123; &#125; dateStart = new Date(); &#125;&#125;test(); 主函数test()执行时间约5*5=25。 按理来说：执行主函数期间setInterval被触发25/8=3次，s1,s2,s3那么test()执行完应立即回调3次，而回调时间基本不耗时。 实际上：在chrome下，执行以上代码，显示，setInterval在主函数执行完后，只回调了一次， 所以，定时器智能化，在任务队列里面只保留一个回调任务，时刻8秒，s1放进去，然后时刻16秒，主逻辑还在执行，s1还在等待，那么s2被丢弃，同理，s3被丢弃。 原因：如果在一个非常大的javascript代码块执行过程中把每次间隔定时器触发的回调函数都放入队列的话，导致的结果是当这个大javascript代码块执行完毕时，有很多的回调函数会被无延迟的依次执行（这和我们当初需要间隔执行的目的相违背），所以，浏览器采用的作法是当等待队列中没有间隔定时器的回调函数时才会放入一个间隔定时器的回调函数。 假设把定时器间隔设定为9秒，那么在主逻辑执行到25秒时间内，有如下调用： 时刻9秒生成回调s1，时刻18秒生成回调s2（丢弃），时刻27秒生成回调s3 结果，大概在第25秒主逻辑执行完毕，从任务队列里面取出s1执行，然后在第27秒，生成s3放到任务队列，然后JS运行时取出执行，s3-s1之间间隔，大概27-25=2s， 所以，定时器不靠谱不靠谱不靠谱！！不能保证每次执行会间隔起码9秒。 这种情况下，可以用setTimeout()嵌套调用，递归。 总结： setTimeout和setInterval的原理是不同的。 如果一个普通的定时器被阻塞了，他会等待直到有合适的时间。 如果间隔定时器回调函数执行时间过长，有可能无间隔的执行。 —————————— 2016.11.24 更新 ——————————————— 三、对于setTimeOut与setInterval的深入思考1234setTimeOut 是用来设定延迟时间1000ms和回调函数fn的定时器，那么，究竟是什么在计算时间呢？回调函数是在什么时候执行的呢？是在等待1000ms的时候？还是一开始就执行了呢？ 1 是什么在计算时间浏览器内核相应模块(例如Webkit 的 Timer 模块)。 2 回调函数的执行 这里跟Event Loop 有关系了。我将js理解为2个线程，1个是主线程，同步；另一个是 任务队列，异步回调的函数就在此处排队。待主线程空闲，就从任务队列中读取事件，这个过程就是事件循环 Event Loop。 当调用setTimeout()方法时，浏览器内核相应模块开始延时方法的处理，当延时方法到达触发条件时，方法被添加到用于回调的任务队列，只要执行引擎栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些满足触发条件的回调函数。 参考文章：你真的了解setTimeout和setInterval吗?你所不知道的setIntervalTAT.ronnie【转向Javascript系列】从setTimeout说事件循环模型How JavaScript Timers Work","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"插入排序","slug":"six","date":"2016-11-05T00:55:29.000Z","updated":"2017-02-03T14:00:50.376Z","comments":true,"path":"2016/11/05/six/","link":"","permalink":"http://yoursite.com/2016/11/05/six/","excerpt":"","text":"算法原理：设有一组关键字｛K1， K2，…， Kn｝；排序开始就认为 K1 是一个有序序列；让 K2 插入上述表长为 1 的有序序列，使之成为一个表长为 2 的有序序列；然后让 K3 插入上述表长为 2 的有序序列，使之成为一个表长为 3 的有序序列；依次类推，最后让 Kn 插入上述表长为 n-1 的有序序列，得一个表长为 n 的有序序列。 个人实现思路：1.设第一个elem( n=0 ) 已排好序A。2.从第二个elem( n=1 )开始，3.在找到准备插入的位置后，需要将该位置之后的数组元素往后挪一位； 所以，在对比之前，要先记录自身元素的值。4.【从后→前】对比，若 A[last] &gt; elem ,那么交换位置，直到 A[elem] &lt; elem ,本轮结束，elem已排好位置。5.重复步骤2-4，直至到达数组最后一位。 12345678910111213141516var arr = [1,3,9,6,5,2,7,2,3,4,8];function insertSort(arr)&#123; for(var i = 1; i &lt; arr.length; i++)&#123; var tmp = arr[i]; for( var j = i-1; j &gt; 0 , arr[j] &gt; tmp; j--)&#123; arr[ j+1 ] = arr[ j ]; arr[ j ] = tmp; &#125; console.log(arr); return arr;&#125;insertSort(arr);","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]},{"title":"Math.random()随机数的一些事一些情","slug":"newone","date":"2016-11-05T00:55:29.000Z","updated":"2017-02-03T13:55:15.485Z","comments":true,"path":"2016/11/05/newone/","link":"","permalink":"http://yoursite.com/2016/11/05/newone/","excerpt":"","text":"Math.random()随机数的一些事一些情一、预备知识Math()12345678910111213141516Math.ceil(); //向上取整。Math.floor(); //向下取整。Math.round(); //四舍五入。Math.random(); //[0,1) 之间的一个伪随机数。Math.ceil(Math.random()*10); // 获取从1到10的随机整数 ，取0的概率极小。Math.round(Math.random()); //可均衡获取0到1的随机整数。Math.floor(Math.random()*10); //可均衡获取0到9的随机整数。Math.round(Math.random()*10); //基本均衡获取0到10的随机整数，其中获取最小值0和最大值10的几率少一半。//因为结果在0~0.4 为0，0.5到1.4为1...8.5到9.4为9，9.5到9.9为10。所以头尾的分布区间只有其他数字的一半。 Date()12345678var d = new Date();var n = d.getSeconds(); //生成0到59的随机数var n1 = d.getMilliseconds(); //生成0到999的随机数var n2 = d.getMilliseconds() % 201; //生成0到200的随机数//除了取 Date 的秒和微秒外，还可以取小时和分钟（跟取秒生成的随机数相同）。 String()1234567891011String.toString() //返回用字符串表示的特定对象String.substr(start[, length]) //返回字符串中从指定位置开始到指定长度的子字符串String.substring(indexStart[, indexEnd]) //返回字符串两个索引之间（或到字符串末尾）的子串String.slice(beginSlice[, endSlice]) //浅复制，提取字符串并返回新字符串RegExp字母ASCII码:A-65,a-97 二、应用 产生10个随机数 12345var arr = [],r;for(var i=0;i&lt;10;i++)&#123; r = (Math.random()/(new Date()-0)).toString(36).replace(/\\d/g,&apos;&apos;).slice(1); arr[i] ? (arr[i]+=1) : (arr[i]=r);&#125; 长度为5的随机数 123for (var c = &apos;&apos;; c.length &lt; 5;) &#123; c += Math.random().toString(36).substr(2,1)&#125; 利用字母ASCII码[65,97]，生成长度为x的随机数 123456789101112function rand(x) &#123; var s = &quot;&quot;; while (s.length &lt; x &amp;&amp; x &gt; 0) &#123; var r = Math.random(); s += String.fromCharCode(Math.floor(r * 26) + (r &gt; 0.5 ? 97 : 65)); &#125; return s;&#125;rand(x); 生成指定范围随机数 1234567891011121314151617Math.floor(Math.random() * (上限 - 下限 + 1) + 下限);Math.ceil(Math.random() * (上限 - 下限) + 下限);parseInt(Math.random() * (上限 - 下限 + 1) + 下限);//under：上限; over：下限; ceilfunction getRandom(under, over) &#123; switch (arguments.length) &#123; case 1: return Math.ceil(Math.random() * under); case 2: return Math.ceil(Math.random() * (over - under) + under); default: return 0; &#125;&#125; 随机背景色 1234567891011//方1&apos;#&apos;+(0x1000000+(Math.random())*0xffffff).toString(16).substr(1,6);//方2&quot;#&quot;+(&quot;000000&quot;+Math.floor(Math.random()*16777216).toString(16)).substr(-6);//方3function randomColor()&#123; var r=function()&#123;return Math.floor(Math.random()*256)&#125;; return &quot;rgb(&quot;+r()+&quot;,&quot;+r()+&quot;,&quot;+r()+&quot;)&quot;;&#125; 洗牌算法 123456789101112var i = 0, data = [], r;for (; i &lt; 10; data[i++] = i);while (--i) &#123; r = Math.round(Math.random() * 9 + 1) - 1; data[i] = data[i] + data[r], data[r] = data[i] - data[r], data[i] = data[i] - data[r];&#125;console.log(data) 或者利用Array.prototype.sort()函数，这里可以不把里面的数值带进来运算。 首先Math.random()会生成一个[0,1)之间的数值，用0.5这个比较公平的数值减去它，概率得到小于0，等于0,大于0三种状况，而Array.prototype.sort()期待的数值恰好是[-1,0,1]，是不是很省事。 1234567891011var i = 0, data = [], r;for (; i &lt; 10; data[i++] = i);data.sort(function() &#123; return .5 - Math.random();&#125;);","raw":null,"content":null,"categories":[{"name":"Exercise","slug":"Exercise","permalink":"http://yoursite.com/categories/Exercise/"}],"tags":[]}]}